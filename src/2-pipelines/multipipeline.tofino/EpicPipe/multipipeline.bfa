version:
  run_id: "155239e1c3294438"
  target: Tofino
error_mode: propagate_and_disable
phv ingress:
  hdr.ethernet.dstAddr.0-31: TW3
  hdr.ethernet.dstAddr.32-47: TH14
  hdr.ethernet.srcAddr.0-31: TW2
  hdr.ethernet.srcAddr.32-47: TH13
  hdr.ethernet.etherType: H8
  hdr.ipv6.version: TW0(28..31)
  hdr.ipv6.traffClass: TW0(20..27)
  hdr.ipv6.flowLabel: TW0(0..19)
  hdr.ipv6.payloadLen: TH15
  hdr.ipv6.nextHeader: B15
  hdr.ipv6.hoplim: TB0
  hdr.ipv6.srcAddr.0-15: TH0
  hdr.ipv6.srcAddr.16-31: TH1
  hdr.ipv6.srcAddr.32-47: TH2
  hdr.ipv6.srcAddr.48-63: TH3
  hdr.ipv6.srcAddr.64-79: TH4
  hdr.ipv6.srcAddr.80-95: TH5
  hdr.ipv6.srcAddr.96-127: TW8
  hdr.ipv6.dstAddr.0-31: W4
  hdr.ipv6.dstAddr.32-63: W9
  hdr.ipv6.dstAddr.64-95: W14
  hdr.ipv6.dstAddr.96-127: W36
  hdr.srh_fixed.nextHeader: TB1
  hdr.srh_fixed.headerLength: TH12(8..15)
  hdr.srh_fixed.routingType: TH12(0..7)
  hdr.srh_fixed.segmentsLeft: B1
  hdr.srh_fixed.last_entry: TW1(24..31)
  hdr.srh_fixed.flags: TW1(16..23)
  hdr.srh_fixed.tag: TW1(0..15)
  hdr.srh_seg$0.segment_address.0-31: W0
  hdr.srh_seg$0.segment_address.32-63: W5
  hdr.srh_seg$0.segment_address.64-95: W10
  hdr.srh_seg$0.segment_address.96-127: W32
  hdr.srh_seg$1.segment_address.0-31: W1
  hdr.srh_seg$1.segment_address.32-63: W6
  hdr.srh_seg$1.segment_address.64-95: W11
  hdr.srh_seg$1.segment_address.96-127: W33
  hdr.srh_seg$2.segment_address.0-31: W2
  hdr.srh_seg$2.segment_address.32-63: W7
  hdr.srh_seg$2.segment_address.64-95: W12
  hdr.srh_seg$2.segment_address.96-127: W34
  hdr.srh_seg$3.segment_address.0-31: W3
  hdr.srh_seg$3.segment_address.32-63: W8
  hdr.srh_seg$3.segment_address.64-95: W13
  hdr.srh_seg$3.segment_address.96-127: W35
  hdr.epic.src_as_host.0-31: W38
  hdr.epic.src_as_host.32-63: W41
  hdr.epic.packet_ts.0-31: W43
  hdr.epic.packet_ts.32-47: H6
  hdr.epic.packet_ts.48-55: B32
  hdr.epic.packet_ts.56-63: B9
  hdr.epic.path_ts: W40
  hdr.epic.per_hop_count: B0
  hdr.epic.nextHeader: B14
  hdr.epic_per_hop.tsexp: B8
  hdr.epic_per_hop.ingress_if: W37(24..31)
  hdr.epic_per_hop.egress_if: W37(16..23)
  hdr.epic_per_hop.segment_identifier: W37(0..15)
  hdr.epic_per_hop.hop_validation.0-15: H3
  hdr.epic_per_hop.hop_validation.16-23: B5
  hdr.mac_res.calculated_mac.0-15: {  stage 0..1: H2 } 
  hdr.mac_res.calculated_mac.16-23: {  stage 0..1: B4 } 
  hdr.mac_res.calculated_mac.24-31: {  stage 0..1: B11 } 
  hdr.mac_load.key_0.0-15: {  stage 1..12: H4 } 
  hdr.mac_load.key_0.16-23: {  stage 1..12: B6 } 
  hdr.mac_load.key_0.24-31: {  stage 1..12: B12 } 
  hdr.mac_load.key_1.0-7: {  stage 1..12: B7 } 
  hdr.mac_load.key_1.8-15: {  stage 1..12: B13 } 
  hdr.mac_load.key_1.16-31: {  stage 1..12: H5 } 
  hdr.mac_load.m_0: {  stage 1..12: W42 } 
  hdr.mac_load.m_1: {  stage 1..12: W39 } 
  hdr.mac_load.m_2.0-15: {  stage 1..12: H7 } 
  hdr.mac_load.m_2.16-23: {  stage 1..12: B33 } 
  hdr.mac_load.m_2.24-31: {  stage 1..12: B10 } 
  hdr.mac_load.m_3: {  stage 1..12: W44 } 
  hdr.mac_load.nextJob: {  stage 1..12: H9 } 
  ig_intr_md_for_tm.ucast_egress_port: {  stage 1..12: H0(0..8) } 
  ig_md.early_exit: {  stage 1: B3(7) } 
  ig_intr_md_for_dprsr.drop_ctl: {  stage 2..12: B3(4..6) } 
  ig_intr_md_for_dprsr.mirror_type: {  stage 12: B2(0..2) } 
  $tmp3: {  stage 12: H1(0..9) } 
  hdr.ethernet.$valid: H10(0)
  hdr.ipv6.$valid: H10(1)
  hdr.srh_fixed.$valid: H10(2)
  hdr.epic.$valid: H10(3)
  hdr.epic_per_hop.$valid: H10(4)
  hdr.mac_load.$valid: {  stage 1..12: H10(5) } 
  hdr.srh_seg.$stkvalid: B3(0..3)
  hdr.srh_seg$0.$valid: {  stage 12: B3(3) } 
  hdr.srh_seg$1.$valid: {  stage 12: B3(2) } 
  hdr.srh_seg$2.$valid: {  stage 12: B3(1) } 
  hdr.srh_seg$3.$valid: B3(0)
phv egress:
  hdr.min_parse_depth_padding_0$0.packet_payload.0-31: TW4
  hdr.min_parse_depth_padding_0$0.packet_payload.32-63: TW5
  hdr.min_parse_depth_padding_0$0.packet_payload.64-79: TH18
  hdr.min_parse_depth_padding_0$0.packet_payload.80-87: TB4
  hdr.min_parse_depth_padding_0$1.packet_payload.0-31: TW6
  hdr.min_parse_depth_padding_0$1.packet_payload.32-63: TW7
  hdr.min_parse_depth_padding_0$1.packet_payload.64-79: TH19
  hdr.min_parse_depth_padding_0$1.packet_payload.80-87: TB5
  hdr.min_parse_depth_padding_0$2.packet_payload.0-15: TH6
  hdr.min_parse_depth_padding_0$2.packet_payload.16-31: TH7
  hdr.min_parse_depth_padding_0$2.packet_payload.32-47: TH8
  hdr.min_parse_depth_padding_0$2.packet_payload.48-63: TH9
  hdr.min_parse_depth_padding_0$2.packet_payload.64-79: TH20
  hdr.min_parse_depth_padding_0$2.packet_payload.80-87: TB6
  hdr.min_parse_depth_padding_0$3.packet_payload.0-15: TH10
  hdr.min_parse_depth_padding_0$3.packet_payload.16-31: TH11
  hdr.min_parse_depth_padding_0$3.packet_payload.32-63: TW12
  hdr.min_parse_depth_padding_0$3.packet_payload.64-79: TH21
  hdr.min_parse_depth_padding_0$3.packet_payload.80-87: TB7
  eg_intr_md.egress_port: H16(0..8)
  hdr.min_parse_depth_padding_0.$stkvalid: B16(0..3)
  hdr.min_parse_depth_padding_0$0.$valid: B16(3)
  hdr.min_parse_depth_padding_0$1.$valid: {  stage 12: B16(2) } 
  hdr.min_parse_depth_padding_0$2.$valid: {  stage 12: B16(1) } 
  hdr.min_parse_depth_padding_0$3.$valid: B16(0)
parser ingress:
  start: $init_match
  init_zero: [ B3, B2, H1, H10 ]
  bitwise_or: [ B3, H10 ]
  hdr_len_adj: 16
  states:
    $init_match:
      *:
        load: { byte1 : 0 }
        shift: 8
        buf_req: 8
        next: $entry_point.start
    $entry_point.start:
      match: [ byte1 ]
      0b1*******:
        8..9: TH14  # ingress::hdr.ethernet.dstAddr[47:32].32-47
        10..13: TW3  # ingress::hdr.ethernet.dstAddr[31:0].0-31
        14..15: TH13  # ingress::hdr.ethernet.srcAddr[47:32].32-47
        16..19: TW2  # ingress::hdr.ethernet.srcAddr[31:0].0-31
        20..21: H8  # ingress::hdr.ethernet.etherType
        H10: 1  # value 1 -> H10 bit[0]: ingress::hdr.ethernet.$valid
        load: { half : 20..21 }
        shift: 22
        buf_req: 22
        next: start_0
      0b0*******:
        8..9: TH14  # ingress::hdr.ethernet.dstAddr[47:32].32-47
        10..13: TW3  # ingress::hdr.ethernet.dstAddr[31:0].0-31
        14..15: TH13  # ingress::hdr.ethernet.srcAddr[47:32].32-47
        16..19: TW2  # ingress::hdr.ethernet.srcAddr[31:0].0-31
        20..21: H8  # ingress::hdr.ethernet.etherType
        H10: 1  # value 1 -> H10 bit[0]: ingress::hdr.ethernet.$valid
        load: { half : 20..21 }
        shift: 22
        buf_req: 22
        next: start_0
    start_0:
      match: [ half ]
      0x86dd:
        0..3: TW0
            # - bit[0..3] -> TW0 bit[31..28]: ingress::hdr.ipv6.version
            # - bit[4..11] -> TW0 bit[27..20]: ingress::hdr.ipv6.traffClass
            # - bit[12..31] -> TW0 bit[19..0]: ingress::hdr.ipv6.flowLabel
        4..5: TH15  # ingress::hdr.ipv6.payloadLen
        6: B15  # ingress::hdr.ipv6.nextHeader
        7: TB0  # ingress::hdr.ipv6.hoplim
        8..11: TW8  # ingress::hdr.ipv6.srcAddr[127:96].96-127
        12..13: TH5  # ingress::hdr.ipv6.srcAddr[95:80].80-95
        14..15: TH4  # ingress::hdr.ipv6.srcAddr[79:64].64-79
        16..17: TH3  # ingress::hdr.ipv6.srcAddr[63:48].48-63
        24..27: W36  # ingress::hdr.ipv6.dstAddr[127:96].96-127
        28..31: W14  # ingress::hdr.ipv6.dstAddr[95:64].64-95
        H10: 2  # value 1 -> H10 bit[1]: ingress::hdr.ipv6.$valid
        load: { byte1 : 6 }
        shift: 18
        buf_req: 32
        next: parse_ipv6.$split_0
      0xea03:
        0: B11  # ingress::hdr.mac_res.calculated_mac[31:24].24-31
        1: B4  # ingress::hdr.mac_res.calculated_mac[23:16].16-23
        2..3: H2  # ingress::hdr.mac_res.calculated_mac[15:0].0-15
        shift: 4
        buf_req: 4
        next: parse_ipv6
      0xea05:
        0: B11  # ingress::hdr.mac_res.calculated_mac[31:24].24-31
        1: B4  # ingress::hdr.mac_res.calculated_mac[23:16].16-23
        2..3: H2  # ingress::hdr.mac_res.calculated_mac[15:0].0-15
        shift: 4
        buf_req: 4
        next: parse_ipv6
      0x****:
        buf_req: 0
        next: end
    parse_ipv6.$split_0:
      match: [ byte1 ]
      0x2b:
        0..1: TH2  # ingress::hdr.ipv6.srcAddr[47:32].32-47
        2..3: TH1  # ingress::hdr.ipv6.srcAddr[31:16].16-31
        4..5: TH0  # ingress::hdr.ipv6.srcAddr[15:0].0-15
        14..17: W9  # ingress::hdr.ipv6.dstAddr[63:32].32-63
        18..21: W4  # ingress::hdr.ipv6.dstAddr[31:0].0-31
        load: { byte1 : 26 }
        shift: 22
        buf_req: 27
        next: parse_srh
      0xfc:
        0..1: TH2  # ingress::hdr.ipv6.srcAddr[47:32].32-47
        2..3: TH1  # ingress::hdr.ipv6.srcAddr[31:16].16-31
        4..5: TH0  # ingress::hdr.ipv6.srcAddr[15:0].0-15
        14..17: W9  # ingress::hdr.ipv6.dstAddr[63:32].32-63
        18..21: W4  # ingress::hdr.ipv6.dstAddr[31:0].0-31
        shift: 22
        buf_req: 22
        next: parse_epic
      0x**:
        0..1: TH2  # ingress::hdr.ipv6.srcAddr[47:32].32-47
        2..3: TH1  # ingress::hdr.ipv6.srcAddr[31:16].16-31
        4..5: TH0  # ingress::hdr.ipv6.srcAddr[15:0].0-15
        14..17: W9  # ingress::hdr.ipv6.dstAddr[63:32].32-63
        18..21: W4  # ingress::hdr.ipv6.dstAddr[31:0].0-31
        shift: 22
        buf_req: 22
        next: end
    parse_srh:
      *:
        counter:
          src: byte1
          max: 3
          rotate: 0
          mask: 1
          add: 1
        0: TB1  # ingress::hdr.srh_fixed.nextHeader
        1..2: TH12
            # - bit[8..15] -> TH12 bit[15..8]: ingress::hdr.srh_fixed.headerLength
            # - bit[16..23] -> TH12 bit[7..0]: ingress::hdr.srh_fixed.routingType
        3: B1  # ingress::hdr.srh_fixed.segmentsLeft
        4..7: TW1
            # - bit[32..39] -> TW1 bit[31..24]: ingress::hdr.srh_fixed.last_entry
            # - bit[40..47] -> TW1 bit[23..16]: ingress::hdr.srh_fixed.flags
            # - bit[48..63] -> TW1 bit[15..0]: ingress::hdr.srh_fixed.tag
        8..11: W32  # ingress::hdr.srh_seg[0].segment_address[127:96].96-127
        12..15: W10  # ingress::hdr.srh_seg[0].segment_address[95:64].64-95
        16..19: W5  # ingress::hdr.srh_seg[0].segment_address[63:32].32-63
        H10: 4  # value 1 -> H10 bit[2]: ingress::hdr.srh_fixed.$valid
        B3: 8  # value 8 -> B3 bit[3..0]: ingress::hdr.srh_seg.$stkvalid
        shift: 20
        buf_req: 20
        next: parse_srh.$split_0
    parse_srh.$split_0:
      *:
        counter: dec 1
        0..3: W0  # ingress::hdr.srh_seg[0].segment_address[31:0].0-31
        shift: 4
        buf_req: 4
        next: parse_srh.$split_1
    parse_srh.$split_1:
      match: [ ctr_zero ]
      0x1:
        0..3: W41  # ingress::hdr.epic.src_as_host[63:32].32-63
        4..7: W38  # ingress::hdr.epic.src_as_host[31:0].0-31
        8: B9  # ingress::hdr.epic.packet_ts[63:56].56-63
        9: B32  # ingress::hdr.epic.packet_ts[55:48].48-55
        10..11: H6  # ingress::hdr.epic.packet_ts[47:32].32-47
        12..15: W43  # ingress::hdr.epic.packet_ts[31:0].0-31
        16..19: W40  # ingress::hdr.epic.path_ts
        20: B0  # ingress::hdr.epic.per_hop_count
        21: B14  # ingress::hdr.epic.nextHeader
        28..29: H3  # ingress::hdr.epic_per_hop.hop_validation[15:0].0-15
        H10: 24
            # - value 1 -> H10 bit[3]: ingress::hdr.epic.$valid
            # - value 1 -> H10 bit[4]: ingress::hdr.epic_per_hop.$valid
        shift: 22
        buf_req: 30
        next: parse_epic.$split_0
      0x0:
        counter: dec 1
        0..3: W33  # ingress::hdr.srh_seg[1].segment_address[127:96].96-127
        4..7: W11  # ingress::hdr.srh_seg[1].segment_address[95:64].64-95
        8..11: W6  # ingress::hdr.srh_seg[1].segment_address[63:32].32-63
        12..15: W1  # ingress::hdr.srh_seg[1].segment_address[31:0].0-31
        B3: 4  # value 4 -> B3 bit[3..0]: ingress::hdr.srh_seg.$stkvalid
        shift: 16
        buf_req: 16
        next: parse_seg1.$split_0
    parse_epic.$split_0:
      *:
        0: B8  # ingress::hdr.epic_per_hop.tsexp
        1..4: W37
            # - bit[8..15] -> W37 bit[31..24]: ingress::hdr.epic_per_hop.ingress_if
            # - bit[16..23] -> W37 bit[23..16]: ingress::hdr.epic_per_hop.egress_if
            # - bit[24..39] -> W37 bit[15..0]: ingress::hdr.epic_per_hop.segment_identifier
        5: B5  # ingress::hdr.epic_per_hop.hop_validation[23:16].16-23
        shift: 8
        buf_req: 8
        next: end
    parse_seg1.$split_0:
      match: [ ctr_zero ]
      0x1:
        0..3: W41  # ingress::hdr.epic.src_as_host[63:32].32-63
        4..7: W38  # ingress::hdr.epic.src_as_host[31:0].0-31
        8: B9  # ingress::hdr.epic.packet_ts[63:56].56-63
        9: B32  # ingress::hdr.epic.packet_ts[55:48].48-55
        10..11: H6  # ingress::hdr.epic.packet_ts[47:32].32-47
        12..15: W43  # ingress::hdr.epic.packet_ts[31:0].0-31
        16..19: W40  # ingress::hdr.epic.path_ts
        20: B0  # ingress::hdr.epic.per_hop_count
        21: B14  # ingress::hdr.epic.nextHeader
        28..29: H3  # ingress::hdr.epic_per_hop.hop_validation[15:0].0-15
        H10: 24
            # - value 1 -> H10 bit[3]: ingress::hdr.epic.$valid
            # - value 1 -> H10 bit[4]: ingress::hdr.epic_per_hop.$valid
        shift: 22
        buf_req: 30
        next: parse_epic.$split_0
      0x0:
        counter: dec 1
        0..3: W34  # ingress::hdr.srh_seg[2].segment_address[127:96].96-127
        4..7: W12  # ingress::hdr.srh_seg[2].segment_address[95:64].64-95
        8..11: W7  # ingress::hdr.srh_seg[2].segment_address[63:32].32-63
        12..15: W2  # ingress::hdr.srh_seg[2].segment_address[31:0].0-31
        B3: 2  # value 2 -> B3 bit[3..0]: ingress::hdr.srh_seg.$stkvalid
        shift: 16
        buf_req: 16
        next: parse_seg2.$split_0
    parse_seg2.$split_0:
      match: [ ctr_zero ]
      0x1:
        0..3: W41  # ingress::hdr.epic.src_as_host[63:32].32-63
        4..7: W38  # ingress::hdr.epic.src_as_host[31:0].0-31
        8: B9  # ingress::hdr.epic.packet_ts[63:56].56-63
        9: B32  # ingress::hdr.epic.packet_ts[55:48].48-55
        10..11: H6  # ingress::hdr.epic.packet_ts[47:32].32-47
        12..15: W43  # ingress::hdr.epic.packet_ts[31:0].0-31
        16..19: W40  # ingress::hdr.epic.path_ts
        20: B0  # ingress::hdr.epic.per_hop_count
        21: B14  # ingress::hdr.epic.nextHeader
        28..29: H3  # ingress::hdr.epic_per_hop.hop_validation[15:0].0-15
        H10: 24
            # - value 1 -> H10 bit[3]: ingress::hdr.epic.$valid
            # - value 1 -> H10 bit[4]: ingress::hdr.epic_per_hop.$valid
        shift: 22
        buf_req: 30
        next: parse_epic.$split_0
      0x0:
        counter: dec 1
        0..3: W35  # ingress::hdr.srh_seg[3].segment_address[127:96].96-127
        4..7: W13  # ingress::hdr.srh_seg[3].segment_address[95:64].64-95
        8..11: W8  # ingress::hdr.srh_seg[3].segment_address[63:32].32-63
        12..15: W3  # ingress::hdr.srh_seg[3].segment_address[31:0].0-31
        B3: 1  # value 1 -> B3 bit[3..0]: ingress::hdr.srh_seg.$stkvalid
        shift: 16
        buf_req: 16
        next: parse_seg3.$split_0
    parse_seg3.$split_0:
      match: [ ctr_zero ]
      0x1:
        0..3: W41  # ingress::hdr.epic.src_as_host[63:32].32-63
        4..7: W38  # ingress::hdr.epic.src_as_host[31:0].0-31
        8: B9  # ingress::hdr.epic.packet_ts[63:56].56-63
        9: B32  # ingress::hdr.epic.packet_ts[55:48].48-55
        10..11: H6  # ingress::hdr.epic.packet_ts[47:32].32-47
        12..15: W43  # ingress::hdr.epic.packet_ts[31:0].0-31
        16..19: W40  # ingress::hdr.epic.path_ts
        20: B0  # ingress::hdr.epic.per_hop_count
        21: B14  # ingress::hdr.epic.nextHeader
        28..29: H3  # ingress::hdr.epic_per_hop.hop_validation[15:0].0-15
        H10: 24
            # - value 1 -> H10 bit[3]: ingress::hdr.epic.$valid
            # - value 1 -> H10 bit[4]: ingress::hdr.epic_per_hop.$valid
        shift: 22
        buf_req: 30
        next: parse_epic.$split_0
      0x0:
        buf_req: 0
        next: end
    parse_epic:
      *:
        0..3: W41  # ingress::hdr.epic.src_as_host[63:32].32-63
        4..7: W38  # ingress::hdr.epic.src_as_host[31:0].0-31
        8: B9  # ingress::hdr.epic.packet_ts[63:56].56-63
        9: B32  # ingress::hdr.epic.packet_ts[55:48].48-55
        10..11: H6  # ingress::hdr.epic.packet_ts[47:32].32-47
        12..15: W43  # ingress::hdr.epic.packet_ts[31:0].0-31
        16..19: W40  # ingress::hdr.epic.path_ts
        20: B0  # ingress::hdr.epic.per_hop_count
        21: B14  # ingress::hdr.epic.nextHeader
        28..29: H3  # ingress::hdr.epic_per_hop.hop_validation[15:0].0-15
        H10: 24
            # - value 1 -> H10 bit[3]: ingress::hdr.epic.$valid
            # - value 1 -> H10 bit[4]: ingress::hdr.epic_per_hop.$valid
        shift: 22
        buf_req: 30
        next: parse_epic.$split_0
    parse_ipv6:
      *:
        0..3: TW0
            # - bit[0..3] -> TW0 bit[31..28]: ingress::hdr.ipv6.version
            # - bit[4..11] -> TW0 bit[27..20]: ingress::hdr.ipv6.traffClass
            # - bit[12..31] -> TW0 bit[19..0]: ingress::hdr.ipv6.flowLabel
        4..5: TH15  # ingress::hdr.ipv6.payloadLen
        6: B15  # ingress::hdr.ipv6.nextHeader
        7: TB0  # ingress::hdr.ipv6.hoplim
        8..11: TW8  # ingress::hdr.ipv6.srcAddr[127:96].96-127
        12..13: TH5  # ingress::hdr.ipv6.srcAddr[95:80].80-95
        14..15: TH4  # ingress::hdr.ipv6.srcAddr[79:64].64-79
        16..17: TH3  # ingress::hdr.ipv6.srcAddr[63:48].48-63
        24..27: W36  # ingress::hdr.ipv6.dstAddr[127:96].96-127
        28..31: W14  # ingress::hdr.ipv6.dstAddr[95:64].64-95
        H10: 2  # value 1 -> H10 bit[1]: ingress::hdr.ipv6.$valid
        load: { byte1 : 6 }
        shift: 18
        buf_req: 32
        next: parse_ipv6.$split_0
deparser ingress:
  dictionary:
    TH14: H10(0)  # ingress::hdr.ethernet.dstAddr.32-47 if ingress::hdr.ethernet.$valid
    TW3: H10(0)  # ingress::hdr.ethernet.dstAddr.0-31 if ingress::hdr.ethernet.$valid
    TH13: H10(0)  # ingress::hdr.ethernet.srcAddr.32-47 if ingress::hdr.ethernet.$valid
    TW2: H10(0)  # ingress::hdr.ethernet.srcAddr.0-31 if ingress::hdr.ethernet.$valid
    H8: H10(0)  # ingress::hdr.ethernet.etherType if ingress::hdr.ethernet.$valid
    B12: H10(5)  # ingress::hdr.mac_load.key_0.24-31 if ingress::hdr.mac_load.$valid
    B6: H10(5)  # ingress::hdr.mac_load.key_0.16-23 if ingress::hdr.mac_load.$valid
    H4: H10(5)  # ingress::hdr.mac_load.key_0.0-15 if ingress::hdr.mac_load.$valid
    H5: H10(5)  # ingress::hdr.mac_load.key_1.16-31 if ingress::hdr.mac_load.$valid
    B13: H10(5)  # ingress::hdr.mac_load.key_1.8-15 if ingress::hdr.mac_load.$valid
    B7: H10(5)  # ingress::hdr.mac_load.key_1.0-7 if ingress::hdr.mac_load.$valid
    W42: H10(5)  # ingress::hdr.mac_load.m_0 if ingress::hdr.mac_load.$valid
    W39: H10(5)  # ingress::hdr.mac_load.m_1 if ingress::hdr.mac_load.$valid
    B10: H10(5)  # ingress::hdr.mac_load.m_2.24-31 if ingress::hdr.mac_load.$valid
    B33: H10(5)  # ingress::hdr.mac_load.m_2.16-23 if ingress::hdr.mac_load.$valid
    H7: H10(5)  # ingress::hdr.mac_load.m_2.0-15 if ingress::hdr.mac_load.$valid
    W44: H10(5)  # ingress::hdr.mac_load.m_3 if ingress::hdr.mac_load.$valid
    H9: H10(5)  # ingress::hdr.mac_load.nextJob if ingress::hdr.mac_load.$valid
    TW0: H10(1)
        # - bit[31..28]: ingress::hdr.ipv6.version if ingress::hdr.ipv6.$valid
        # - bit[27..20]: ingress::hdr.ipv6.traffClass if ingress::hdr.ipv6.$valid
        # - bit[19..0]: ingress::hdr.ipv6.flowLabel if ingress::hdr.ipv6.$valid
    TH15: H10(1)  # ingress::hdr.ipv6.payloadLen if ingress::hdr.ipv6.$valid
    B15: H10(1)  # ingress::hdr.ipv6.nextHeader if ingress::hdr.ipv6.$valid
    TB0: H10(1)  # ingress::hdr.ipv6.hoplim if ingress::hdr.ipv6.$valid
    TW8: H10(1)  # ingress::hdr.ipv6.srcAddr.96-127 if ingress::hdr.ipv6.$valid
    TH5: H10(1)  # ingress::hdr.ipv6.srcAddr.80-95 if ingress::hdr.ipv6.$valid
    TH4: H10(1)  # ingress::hdr.ipv6.srcAddr.64-79 if ingress::hdr.ipv6.$valid
    TH3: H10(1)  # ingress::hdr.ipv6.srcAddr.48-63 if ingress::hdr.ipv6.$valid
    TH2: H10(1)  # ingress::hdr.ipv6.srcAddr.32-47 if ingress::hdr.ipv6.$valid
    TH1: H10(1)  # ingress::hdr.ipv6.srcAddr.16-31 if ingress::hdr.ipv6.$valid
    TH0: H10(1)  # ingress::hdr.ipv6.srcAddr.0-15 if ingress::hdr.ipv6.$valid
    W36: H10(1)  # ingress::hdr.ipv6.dstAddr.96-127 if ingress::hdr.ipv6.$valid
    W14: H10(1)  # ingress::hdr.ipv6.dstAddr.64-95 if ingress::hdr.ipv6.$valid
    W9: H10(1)  # ingress::hdr.ipv6.dstAddr.32-63 if ingress::hdr.ipv6.$valid
    W4: H10(1)  # ingress::hdr.ipv6.dstAddr.0-31 if ingress::hdr.ipv6.$valid
    TB1: H10(2)  # ingress::hdr.srh_fixed.nextHeader if ingress::hdr.srh_fixed.$valid
    TH12: H10(2)
        # - bit[15..8]: ingress::hdr.srh_fixed.headerLength if ingress::hdr.srh_fixed.$valid
        # - bit[7..0]: ingress::hdr.srh_fixed.routingType if ingress::hdr.srh_fixed.$valid
    B1: H10(2)  # ingress::hdr.srh_fixed.segmentsLeft if ingress::hdr.srh_fixed.$valid
    TW1: H10(2)
        # - bit[31..24]: ingress::hdr.srh_fixed.last_entry if ingress::hdr.srh_fixed.$valid
        # - bit[23..16]: ingress::hdr.srh_fixed.flags if ingress::hdr.srh_fixed.$valid
        # - bit[15..0]: ingress::hdr.srh_fixed.tag if ingress::hdr.srh_fixed.$valid
    W32: B3(3)  # ingress::hdr.srh_seg[0].segment_address.96-127 if ingress::hdr.srh_seg[0].$valid
    W10: B3(3)  # ingress::hdr.srh_seg[0].segment_address.64-95 if ingress::hdr.srh_seg[0].$valid
    W5: B3(3)  # ingress::hdr.srh_seg[0].segment_address.32-63 if ingress::hdr.srh_seg[0].$valid
    W0: B3(3)  # ingress::hdr.srh_seg[0].segment_address.0-31 if ingress::hdr.srh_seg[0].$valid
    W33: B3(2)  # ingress::hdr.srh_seg[1].segment_address.96-127 if ingress::hdr.srh_seg[1].$valid
    W11: B3(2)  # ingress::hdr.srh_seg[1].segment_address.64-95 if ingress::hdr.srh_seg[1].$valid
    W6: B3(2)  # ingress::hdr.srh_seg[1].segment_address.32-63 if ingress::hdr.srh_seg[1].$valid
    W1: B3(2)  # ingress::hdr.srh_seg[1].segment_address.0-31 if ingress::hdr.srh_seg[1].$valid
    W34: B3(1)  # ingress::hdr.srh_seg[2].segment_address.96-127 if ingress::hdr.srh_seg[2].$valid
    W12: B3(1)  # ingress::hdr.srh_seg[2].segment_address.64-95 if ingress::hdr.srh_seg[2].$valid
    W7: B3(1)  # ingress::hdr.srh_seg[2].segment_address.32-63 if ingress::hdr.srh_seg[2].$valid
    W2: B3(1)  # ingress::hdr.srh_seg[2].segment_address.0-31 if ingress::hdr.srh_seg[2].$valid
    W35: B3(0)  # ingress::hdr.srh_seg[3].segment_address.96-127 if ingress::hdr.srh_seg[3].$valid
    W13: B3(0)  # ingress::hdr.srh_seg[3].segment_address.64-95 if ingress::hdr.srh_seg[3].$valid
    W8: B3(0)  # ingress::hdr.srh_seg[3].segment_address.32-63 if ingress::hdr.srh_seg[3].$valid
    W3: B3(0)  # ingress::hdr.srh_seg[3].segment_address.0-31 if ingress::hdr.srh_seg[3].$valid
    W41: H10(3)  # ingress::hdr.epic.src_as_host.32-63 if ingress::hdr.epic.$valid
    W38: H10(3)  # ingress::hdr.epic.src_as_host.0-31 if ingress::hdr.epic.$valid
    B9: H10(3)  # ingress::hdr.epic.packet_ts.56-63 if ingress::hdr.epic.$valid
    B32: H10(3)  # ingress::hdr.epic.packet_ts.48-55 if ingress::hdr.epic.$valid
    H6: H10(3)  # ingress::hdr.epic.packet_ts.32-47 if ingress::hdr.epic.$valid
    W43: H10(3)  # ingress::hdr.epic.packet_ts.0-31 if ingress::hdr.epic.$valid
    W40: H10(3)  # ingress::hdr.epic.path_ts if ingress::hdr.epic.$valid
    B0: H10(3)  # ingress::hdr.epic.per_hop_count if ingress::hdr.epic.$valid
    B14: H10(3)  # ingress::hdr.epic.nextHeader if ingress::hdr.epic.$valid
    B8: H10(4)  # ingress::hdr.epic_per_hop.tsexp if ingress::hdr.epic_per_hop.$valid
    W37: H10(4)
        # - bit[31..24]: ingress::hdr.epic_per_hop.ingress_if if ingress::hdr.epic_per_hop.$valid
        # - bit[23..16]: ingress::hdr.epic_per_hop.egress_if if ingress::hdr.epic_per_hop.$valid
        # - bit[15..0]: ingress::hdr.epic_per_hop.segment_identifier if ingress::hdr.epic_per_hop.$valid
    B5: H10(4)  # ingress::hdr.epic_per_hop.hop_validation.16-23 if ingress::hdr.epic_per_hop.$valid
    H3: H10(4)  # ingress::hdr.epic_per_hop.hop_validation.0-15 if ingress::hdr.epic_per_hop.$valid
  egress_unicast_port: H0(0..8)  # bit[8..0]: ingress::ig_intr_md_for_tm.ucast_egress_port
  drop_ctl: B3(4..6)  # bit[6..4]: ingress::ig_intr_md_for_dprsr.drop_ctl
  mirror:
    select: B2(0..2)  # bit[2..0]: ingress::ig_intr_md_for_dprsr.mirror_type
    0:
      - H1(0..9)  # bit[9..0]: ingress::$tmp3
parser egress:
  start: $entry_point.start.min_parse_depth_accept_initial
  init_zero: [ B16 ]
  bitwise_or: [ B16 ]
  hdr_len_adj: 27
  meta_opt: 8191
  states:
    $entry_point.start.min_parse_depth_accept_initial:
      *:
        counter:
          imm: 38
        0..1: H16  # bit[7..15] -> H16 bit[8..0]: egress::eg_intr_md.egress_port
        intr_md: 9
        shift: 27
        buf_req: 27
        next: $entry_point.start.min_parse_depth_accept_initial.$ctr_stall0
    $entry_point.start.min_parse_depth_accept_initial.$ctr_stall0:
      *:
        buf_req: 0
        next: $entry_point.start.min_parse_depth_accept_initial.$split_0
    $entry_point.start.min_parse_depth_accept_initial.$split_0:
      match: [ ctr_neg, ctr_zero ]
      0x0:
        counter: dec 11
        0: TB4  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[87:80].80-87
        1..2: TH18  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[79:64].64-79
        3..6: TW5  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[63:32].32-63
        7..10: TW4  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[31:0].0-31
        B16: 8  # value 8 -> B16 bit[3..0]: egress::hdr.min_parse_depth_padding_0.$stkvalid
        shift: 11
        buf_req: 11
        next: min_parse_depth_accept_loop.$split_0
      0b**:
        buf_req: 0
        next: end
    min_parse_depth_accept_loop.$split_0:
      match: [ ctr_neg, ctr_zero ]
      option: ignore_max_depth
      0x0:
        counter: dec 11
        0: TB5  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[87:80].80-87
        1..2: TH19  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[79:64].64-79
        3..6: TW7  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[63:32].32-63
        7..10: TW6  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[31:0].0-31
        B16: 4  # value 4 -> B16 bit[3..0]: egress::hdr.min_parse_depth_padding_0.$stkvalid
        shift: 11
        buf_req: 11
        next: min_parse_depth_accept_loop.$it1.$split_0
      0b**:
        buf_req: 0
        next: end
    min_parse_depth_accept_loop.$it1.$split_0:
      match: [ ctr_neg, ctr_zero ]
      option: ignore_max_depth
      0x0:
        counter: dec 11
        0: TB6  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[87:80].80-87
        1..2: TH20  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[79:64].64-79
        3..4: TH9  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[63:48].48-63
        5..6: TH8  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[47:32].32-47
        7..8: TH7  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[31:16].16-31
        B16: 2  # value 2 -> B16 bit[3..0]: egress::hdr.min_parse_depth_padding_0.$stkvalid
        shift: 9
        buf_req: 9
        next: min_parse_depth_accept_loop.$it2.$split_0
      0b**:
        buf_req: 0
        next: end
    min_parse_depth_accept_loop.$it2.$split_0:
      match: [ ctr_neg, ctr_zero ]
      option: ignore_max_depth
      0x0:
        counter: dec 11
        0..1: TH6  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[15:0].0-15
        2: TB7  # egress::hdr.min_parse_depth_padding_0[3].packet_payload[87:80].80-87
        3..4: TH21  # egress::hdr.min_parse_depth_padding_0[3].packet_payload[79:64].64-79
        5..8: TW12  # egress::hdr.min_parse_depth_padding_0[3].packet_payload[63:32].32-63
        9..10: TH11  # egress::hdr.min_parse_depth_padding_0[3].packet_payload[31:16].16-31
        11..12: TH10  # egress::hdr.min_parse_depth_padding_0[3].packet_payload[15:0].0-15
        B16: 1  # value 1 -> B16 bit[3..0]: egress::hdr.min_parse_depth_padding_0.$stkvalid
        shift: 13
        buf_req: 13
        next: end
      0b**:
        0..1: TH6  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[15:0].0-15
        shift: 2
        buf_req: 2
        next: end
deparser egress:
  dictionary:
    TB4: B16(3)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.80-87 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TH18: B16(3)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.64-79 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TW5: B16(3)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.32-63 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TW4: B16(3)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.0-31 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TB5: B16(2)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.80-87 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TH19: B16(2)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.64-79 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TW7: B16(2)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.32-63 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TW6: B16(2)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.0-31 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TB6: B16(1)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.80-87 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TH20: B16(1)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.64-79 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TH9: B16(1)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.48-63 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TH8: B16(1)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.32-47 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TH7: B16(1)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.16-31 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TH6: B16(1)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.0-15 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TB7: B16(0)  # egress::hdr.min_parse_depth_padding_0[3].packet_payload.80-87 if egress::hdr.min_parse_depth_padding_0[3].$valid
    TH21: B16(0)  # egress::hdr.min_parse_depth_padding_0[3].packet_payload.64-79 if egress::hdr.min_parse_depth_padding_0[3].$valid
    TW12: B16(0)  # egress::hdr.min_parse_depth_padding_0[3].packet_payload.32-63 if egress::hdr.min_parse_depth_padding_0[3].$valid
    TH11: B16(0)  # egress::hdr.min_parse_depth_padding_0[3].packet_payload.16-31 if egress::hdr.min_parse_depth_padding_0[3].$valid
    TH10: B16(0)  # egress::hdr.min_parse_depth_padding_0[3].packet_payload.0-15 if egress::hdr.min_parse_depth_padding_0[3].$valid
  egress_unicast_port: H16(0..8)  # bit[8..0]: egress::eg_intr_md.egress_port
stage 0 ingress:
  phase0_match EpicIngressParser.$PORT_METADATA:
    p4:
      name: EpicIngressParser.$PORT_METADATA
      size: 288
      preferred_match_type: exact
      match_type: exact
    size: 288
    p4_param_order:
      ig_intr_md.ingress_port: { type: exact, size: 9 }
    format: {ig_intr_md: 0..63}
    constant_value: 0
    actions:
      set_port_metadata:
      - handle: 0x20000000
      - p4_param_order: { ig_intr_md: 64 } 
  exact_match epic_stage_0 0:
    p4: { name: EpicIngress.epic_stage, size: 32 }
    p4_param_order: 
      hdr.ethernet.etherType: { type: exact, size: 16, full_size: 16 }
    row: 7
    bus: 0
    column: [ 2, 3, 4, 5 ]
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - { group: 0, index: 0..9, select: 40..51 & 0x0, rams: [[7, 2]] }
      - { group: 0, index: 10..19, select: 40..51 & 0x0, rams: [[7, 3]] }
      - { group: 0, index: 20..29, select: 40..51 & 0x0, rams: [[7, 4]] }
      - { group: 0, index: 30..39, select: 40..51 & 0x0, rams: [[7, 5]] }
    input_xbar:
      exact group 0: { 0: hdr.ethernet.etherType }
      hash 0:
        0..7: random(hdr.ethernet.etherType(10..15)) ^ hdr.ethernet.etherType(0..7)
        8..9: random(hdr.ethernet.etherType(10..15)) ^ hdr.ethernet.etherType(8..9)
        11..18: random(hdr.ethernet.etherType(10..15)) ^ hdr.ethernet.etherType(0..7)
        19: random(hdr.ethernet.etherType(10..15)) ^ hdr.ethernet.etherType(8)
        10: random(hdr.ethernet.etherType(10..15)) ^ hdr.ethernet.etherType(9)
        22..29: random(hdr.ethernet.etherType(10..15)) ^ hdr.ethernet.etherType(0..7)
        20..21: random(hdr.ethernet.etherType(10..15)) ^ hdr.ethernet.etherType(8..9)
        33..39: random(hdr.ethernet.etherType(10..15)) ^ hdr.ethernet.etherType(0..6)
        30: random(hdr.ethernet.etherType(10..15)) ^ hdr.ethernet.etherType(7)
        31..32: random(hdr.ethernet.etherType(10..15)) ^ hdr.ethernet.etherType(8..9)
      hash group 0:
        table: [0]
        seed: 0x8aac779260
    format: { action(0): 0..1, immediate(0): 10..18, version(0): 112..115, match(0): 58..63, action(1): 2..3, immediate(1): 19..27, version(1): 116..119, match(1): 66..71, action(2): 4..5, immediate(2): 28..36, version(2): 120..123, match(2): 74..79, action(3): 6..7, immediate(3): 37..45, version(3): 124..127, match(3): 82..87, action(4): 8..9, immediate(4): 46..54, version(4): 96..99, match(4): 90..95 }
    match: [ hdr.ethernet.etherType(10..15) ]
    match_group_map: [ [ 0, 1, 2, 3, 4 ] ]
    hit: [  tbl_EPICPipe374 ]
    miss:  tbl_EPICPipe374
    action_bus: { 32..33 : immediate(0..8) }
    instruction: epic_stage_0(action, $DEFAULT)
    actions:
      EpicIngress.create_hop_authenticator(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000001
      - next_table: 0
      - { $constant0: immediate(0..8), $constant0: 196 }
      - set hdr.mac_load.$valid, 1
      - set hdr.mac_load.key_0.0-15, 12592
      - set hdr.mac_load.key_0.16-23, 50
      - set hdr.mac_load.key_0.24-31, 51
      - set hdr.mac_load.key_1.0-7, 56
      - set hdr.mac_load.key_1.8-15, 57
      - set hdr.mac_load.key_1.16-31, 16961
      - set hdr.mac_load.m_0, hdr.epic.path_ts
      - set hdr.mac_load.m_2.24-31, hdr.epic_per_hop.tsexp
      - set hdr.mac_load.m_2.0-15, 0
      - set hdr.mac_load.m_2.16-23, 0
      - set hdr.mac_load.m_3, 0
      - set hdr.ethernet.etherType, 59906
      - set hdr.mac_load.nextJob, 59907
      - set ig_intr_md_for_tm.ucast_egress_port, $constant0
      - set ig_md.early_exit, 1
      - set W39(0..31), W37
      EpicIngress.create_packet_authorization(1, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000002
      - next_table: 0
      - { $constant0: immediate(0..8), $constant0: 196 }
      - set hdr.mac_load.$valid, 1
      - set hdr.mac_load.key_0.0-15, hdr.mac_res.calculated_mac.0-15
      - set hdr.mac_load.key_0.16-23, hdr.mac_res.calculated_mac.16-23
      - set hdr.mac_load.key_0.24-31, hdr.mac_res.calculated_mac.24-31
      - set hdr.mac_load.key_1.16-31, hdr.mac_res.calculated_mac.0-15
      - set hdr.mac_load.key_1.0-7, hdr.mac_res.calculated_mac.16-23
      - set hdr.mac_load.key_1.8-15, hdr.mac_res.calculated_mac.24-31
      - set hdr.mac_load.m_0, hdr.epic.src_as_host.32-63
      - set hdr.mac_load.m_1, hdr.epic.src_as_host.0-31
      - set hdr.mac_load.m_2.0-15, hdr.epic.packet_ts.32-47
      - set hdr.mac_load.m_2.16-23, hdr.epic.packet_ts.48-55
      - set hdr.mac_load.m_2.24-31, hdr.epic.packet_ts.56-63
      - set hdr.mac_load.m_3, hdr.epic.packet_ts.0-31
      - set hdr.ethernet.etherType, 59908
      - set hdr.mac_load.nextJob, 59909
      - set ig_intr_md_for_tm.ucast_egress_port, $constant0
      - set ig_md.early_exit, 1
      EpicIngress.nop(2, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000003
      - next_table: 0
      - {  }
    default_action: EpicIngress.nop
stage 1 ingress:
  dependency: match
  ternary_match tbl_EPICPipe374 0:
    p4: { name: tbl_EPICPipe374, hidden: true }
    gateway:
      name: cond-9
      input_xbar:
        exact group 0: { 7: ig_md.early_exit }
      row: 0
      bus: 1
      unit: 1
      match: { 7: ig_md.early_exit }
      0x1:
        run_table: true
      miss:
        next:  srv6_0
      condition: 
        expression: "(ig_md.early_exit)"
        true:  tbl_EPICPipe374
        false:  srv6_0
    hit: [  END ]
    miss:  END
    indirect: tbl_EPICPipe374$tind
  ternary_indirect tbl_EPICPipe374$tind:
    row: 2
    bus: 0
    format: { action: 0..0 }
    instruction: tbl_EPICPipe374$tind(action, $DEFAULT)
    actions:
      EPICPipe374(1, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000004
      - next_table: 0
    default_action: EPICPipe374
  exact_match srv6_0 1:
    p4: { name: EpicIngress.srv6, size: 32 }
    p4_param_order: 
      hdr.ipv6.dstAddr: { type: exact, size: 128, full_size: 128 }
      hdr.srh_fixed.segmentsLeft: { type: exact, size: 8, full_size: 8 }
    row: [ 6, 7 ]
    bus: [ 0, 0 ]
    column:
    - [ 2, 3, 4, 5 ]
    - [ 2, 3, 4, 5 ]
    stash: 
      row: [ 6, 7 ]
      col: [ 2, 2 ]
      unit: [ 0, 0 ]
    ways:
      - { group: 0, index: 0..9, select: 40..51 & 0x0, rams: [[7, 2], [6, 2]] }
      - { group: 0, index: 10..19, select: 40..51 & 0x0, rams: [[7, 3], [6, 3]] }
      - { group: 0, index: 20..29, select: 40..51 & 0x0, rams: [[7, 4], [6, 4]] }
      - { group: 0, index: 30..39, select: 40..51 & 0x0, rams: [[7, 5], [6, 5]] }
    input_xbar:
      exact group 0: { 8: hdr.ipv6.dstAddr.0-31(8..31), 32: hdr.ipv6.dstAddr.0-31(0..7), 40: hdr.ipv6.dstAddr.32-63(8..31), 64: hdr.ipv6.dstAddr.32-63(0..7), 72: hdr.ipv6.dstAddr.64-95(8..31), 96: hdr.ipv6.dstAddr.64-95(0..7), 104: hdr.ipv6.dstAddr.96-127(8..31) }
      exact group 1: { 0: hdr.ipv6.dstAddr.96-127(0..7), 8: hdr.srh_fixed.segmentsLeft }
      hash 0:
        0..9: random(hdr.ipv6.dstAddr.0-31(8..31), hdr.ipv6.dstAddr.0-31(0..7), hdr.ipv6.dstAddr.32-63(8..31))
        10..19: random(hdr.ipv6.dstAddr.0-31(8..31), hdr.ipv6.dstAddr.0-31(0..7), hdr.ipv6.dstAddr.32-63(8..31))
        20..29: random(hdr.ipv6.dstAddr.0-31(8..31), hdr.ipv6.dstAddr.0-31(0..7), hdr.ipv6.dstAddr.32-63(8..31))
        30..39: random(hdr.ipv6.dstAddr.0-31(8..31), hdr.ipv6.dstAddr.0-31(0..7), hdr.ipv6.dstAddr.32-63(8..31))
      hash 1:
        0..9: random(hdr.ipv6.dstAddr.32-63(0..7), hdr.ipv6.dstAddr.64-95(8..31), hdr.ipv6.dstAddr.64-95(0..7), hdr.ipv6.dstAddr.96-127(8..31))
        10..19: random(hdr.ipv6.dstAddr.32-63(0..7), hdr.ipv6.dstAddr.64-95(8..31), hdr.ipv6.dstAddr.64-95(0..7), hdr.ipv6.dstAddr.96-127(8..31))
        20..29: random(hdr.ipv6.dstAddr.32-63(0..7), hdr.ipv6.dstAddr.64-95(8..31), hdr.ipv6.dstAddr.64-95(0..7), hdr.ipv6.dstAddr.96-127(8..31))
        30..39: random(hdr.ipv6.dstAddr.32-63(0..7), hdr.ipv6.dstAddr.64-95(8..31), hdr.ipv6.dstAddr.64-95(0..7), hdr.ipv6.dstAddr.96-127(8..31))
      hash 2:
        0..1: random(hdr.ipv6.dstAddr.96-127(2..7)) ^ hdr.ipv6.dstAddr.96-127(0..1)
        2..9: random(hdr.ipv6.dstAddr.96-127(2..7)) ^ hdr.srh_fixed.segmentsLeft
        11..12: random(hdr.ipv6.dstAddr.96-127(2..7)) ^ hdr.ipv6.dstAddr.96-127(0..1)
        13..19: random(hdr.ipv6.dstAddr.96-127(2..7)) ^ hdr.srh_fixed.segmentsLeft(0..6)
        10: random(hdr.ipv6.dstAddr.96-127(2..7)) ^ hdr.srh_fixed.segmentsLeft(7)
        22..23: random(hdr.ipv6.dstAddr.96-127(2..7)) ^ hdr.ipv6.dstAddr.96-127(0..1)
        24..29: random(hdr.ipv6.dstAddr.96-127(2..7)) ^ hdr.srh_fixed.segmentsLeft(0..5)
        20..21: random(hdr.ipv6.dstAddr.96-127(2..7)) ^ hdr.srh_fixed.segmentsLeft(6..7)
        33..34: random(hdr.ipv6.dstAddr.96-127(2..7)) ^ hdr.ipv6.dstAddr.96-127(0..1)
        35..39: random(hdr.ipv6.dstAddr.96-127(2..7)) ^ hdr.srh_fixed.segmentsLeft(0..4)
        30..32: random(hdr.ipv6.dstAddr.96-127(2..7)) ^ hdr.srh_fixed.segmentsLeft(5..7)
      hash group 0:
        table: [0, 1, 2]
        seed: 0x5425eee115
    format: { action(0): 0..2, version(0): 112..115, match(0): [ 160..239, 128..143, 34..39, 144..159, 240..247 ] }
    match: [ hdr.ipv6.dstAddr.0-31(0..7), hdr.ipv6.dstAddr.0-31(8..15), hdr.ipv6.dstAddr.0-31(16..23), hdr.ipv6.dstAddr.0-31(24..31), hdr.ipv6.dstAddr.32-63(0..7), hdr.ipv6.dstAddr.32-63(8..15), hdr.ipv6.dstAddr.32-63(16..23), hdr.ipv6.dstAddr.32-63(24..31), hdr.ipv6.dstAddr.64-95(0..7), hdr.ipv6.dstAddr.64-95(8..15), hdr.ipv6.dstAddr.64-95(16..23), hdr.ipv6.dstAddr.64-95(24..31), hdr.ipv6.dstAddr.96-127(2..7), hdr.ipv6.dstAddr.96-127(8..15), hdr.ipv6.dstAddr.96-127(16..23), hdr.ipv6.dstAddr.96-127(24..31) ]
    match_group_map: [ [ 0 ], [ 0 ] ]
    hit: [  cond-10 ]
    miss:  cond-10
    instruction: srv6_0(action, $DEFAULT)
    actions:
      EpicIngress.srv6_next_0(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000005
      - next_table: 0
      - set hdr.ipv6.dstAddr.0-31, hdr.srh_seg$0.segment_address.0-31
      - set hdr.ipv6.dstAddr.32-63, hdr.srh_seg$0.segment_address.32-63
      - set hdr.ipv6.dstAddr.64-95, hdr.srh_seg$0.segment_address.64-95
      - set hdr.ipv6.dstAddr.96-127, hdr.srh_seg$0.segment_address.96-127
      - add B1, 255, B1
      EpicIngress.srv6_next_1(1, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000006
      - next_table: 0
      - set hdr.ipv6.dstAddr.0-31, hdr.srh_seg$1.segment_address.0-31
      - set hdr.ipv6.dstAddr.32-63, hdr.srh_seg$1.segment_address.32-63
      - set hdr.ipv6.dstAddr.64-95, hdr.srh_seg$1.segment_address.64-95
      - set hdr.ipv6.dstAddr.96-127, hdr.srh_seg$1.segment_address.96-127
      - add B1, 255, B1
      EpicIngress.srv6_next_2(2, 4):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000007
      - next_table: 0
      - set hdr.ipv6.dstAddr.0-31, hdr.srh_seg$2.segment_address.0-31
      - set hdr.ipv6.dstAddr.32-63, hdr.srh_seg$2.segment_address.32-63
      - set hdr.ipv6.dstAddr.64-95, hdr.srh_seg$2.segment_address.64-95
      - set hdr.ipv6.dstAddr.96-127, hdr.srh_seg$2.segment_address.96-127
      - add B1, 255, B1
      EpicIngress.srv6_next_3(3, 6):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000008
      - next_table: 0
      - set hdr.ipv6.dstAddr.0-31, hdr.srh_seg$3.segment_address.0-31
      - set hdr.ipv6.dstAddr.32-63, hdr.srh_seg$3.segment_address.32-63
      - set hdr.ipv6.dstAddr.64-95, hdr.srh_seg$3.segment_address.64-95
      - set hdr.ipv6.dstAddr.96-127, hdr.srh_seg$3.segment_address.96-127
      - add B1, 255, B1
      EpicIngress.nop(4, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000009
      - next_table: 0
    default_action: EpicIngress.nop
  gateway cond-10 2:
    name: cond-10
    input_xbar:
      exact group 1: { 16: hdr.ethernet.etherType }
    row: 6
    bus: 0
    unit: 0
    match: { 0: hdr.ethernet.etherType(0..7), 8: hdr.ethernet.etherType(8..15) }
    0xea05:
      next:  tbl_drop
    miss:
      next:  END
    condition: 
      expression: "(hdr.ethernet.etherType == 59909)"
      true:  tbl_drop
      false:  END
  ternary_match tbl_drop 3:
    p4: { name: tbl_drop, hidden: true }
    gateway:
      name: cond-11
      input_xbar:
        exact group 1: { 32: hdr.epic_per_hop.hop_validation.0-15, 48: hdr.mac_res.calculated_mac.0-15, 64: hdr.epic_per_hop.hop_validation.16-23, 72: hdr.mac_res.calculated_mac.16-23 }
      row: 0
      bus: 0
      unit: 0
      match: { 0: hdr.mac_res.calculated_mac.0-15(0..7), 8: hdr.mac_res.calculated_mac.0-15(8..15), 16: hdr.mac_res.calculated_mac.16-23 }
      xor: { 0: hdr.epic_per_hop.hop_validation.0-15(0..7), 8: hdr.epic_per_hop.hop_validation.0-15(8..15), 16: hdr.epic_per_hop.hop_validation.16-23 }
      0x000000:
        next:  tbl_EPICPipe392
      miss:
        run_table: true
      condition: 
        expression: "(hdr.mac_res.calculated_mac[23:0] != hdr.epic_per_hop.hop_validation)"
        true:  tbl_drop
        false:  tbl_EPICPipe392
    hit: [  tbl_EPICPipe380 ]
    miss:  tbl_EPICPipe380
    indirect: tbl_drop$tind
  ternary_indirect tbl_drop$tind:
    row: 1
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_drop$tind(action, $DEFAULT)
    actions:
      EpicIngress.drop(1, 3):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000000e
      - next_table: 0
      - set ig_intr_md_for_dprsr.drop_ctl, 1
    default_action: EpicIngress.drop
  ternary_match tbl_EPICPipe392 4:
    p4: { name: tbl_EPICPipe392, hidden: true }
    hit: [  tbl_EPICPipe383 ]
    miss:  tbl_EPICPipe383
    indirect: tbl_EPICPipe392$tind
  ternary_indirect tbl_EPICPipe392$tind:
    row: 1
    bus: 0
    format: { action: 0..0 }
    instruction: tbl_EPICPipe392$tind(action, $DEFAULT)
    actions:
      EPICPipe392(0, 5):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000000d
      - next_table: 0
      - set hdr.epic_per_hop.$valid, 0
    default_action: EPICPipe392
  ternary_match tbl_EPICPipe383 5:
    p4: { name: tbl_EPICPipe383, hidden: true }
    hit: [  tbl_EPICPipe386 ]
    miss:  tbl_EPICPipe386
    indirect: tbl_EPICPipe383$tind
  ternary_indirect tbl_EPICPipe383$tind:
    row: 0
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_EPICPipe383$tind(action, $DEFAULT)
    actions:
      EPICPipe383(0, 7):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000000a
      - next_table: 0
      - set hdr.ethernet.etherType, 34525
    default_action: EPICPipe383
  ternary_match tbl_EPICPipe386 7:
    p4: { name: tbl_EPICPipe386, hidden: true }
    gateway:
      name: cond-12
      input_xbar:
        exact group 1: { 81: hdr.epic.per_hop_count(1..7) }
      row: 1
      bus: 0
      unit: 0
      match: { 1: hdr.epic.per_hop_count(1..7) }
      0x00:
        next:  tbl_EPICPipe388
      miss:
        run_table: true
      condition: 
        expression: "(hdr.epic.per_hop_count > 1)"
        true:  tbl_EPICPipe386
        false:  tbl_EPICPipe388
    hit: [  END ]
    miss:  END
    indirect: tbl_EPICPipe386$tind
  ternary_indirect tbl_EPICPipe386$tind:
    row: 2
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_EPICPipe386$tind(action, $DEFAULT)
    actions:
      EPICPipe386(1, 8):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000000c
      - next_table: 0
      - add B0, 255, B0
    default_action: EPICPipe386
  ternary_match tbl_EPICPipe380 6:
    p4: { name: tbl_EPICPipe380, hidden: true }
    hit: [  END ]
    miss:  END
    indirect: tbl_EPICPipe380$tind
  ternary_indirect tbl_EPICPipe380$tind:
    row: 0
    bus: 0
    format: { action: 0..0 }
    instruction: tbl_EPICPipe380$tind(action, $DEFAULT)
    actions:
      EPICPipe380(0, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000000f
      - next_table: 0
    default_action: EPICPipe380
stage 2 ingress:
  dependency: action
  ternary_match tbl_EPICPipe388 0:
    p4: { name: tbl_EPICPipe388, hidden: true }
    hit: [  END ]
    miss:  END
    indirect: tbl_EPICPipe388$tind
  ternary_indirect tbl_EPICPipe388$tind:
    row: 0
    bus: 0
    format: { action: 0..0 }
    instruction: tbl_EPICPipe388$tind(action, $DEFAULT)
    actions:
      EPICPipe388(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000000b
      - next_table: 0
      - set hdr.ipv6.nextHeader, hdr.epic.nextHeader
      - set hdr.epic.$valid, 0
    default_action: EPICPipe388


primitives: "multipipeline.prim.json"
dynhash: "multipipeline.dynhash.json"
